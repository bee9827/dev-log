# 5. 가독성 높은 코드를 작성하라

## 이번 장에서는 다음과 같은 내용을 다룬다.
- 코드가 그 자체로 설명이 되도록 하기 위한 방법   
- 다른 사람들에게 코드의 세부적 내용을 명확하게 함
- 언어의 기능을 사용할 때 그에 합당한 이유를 가져야 함

## 5.1 서술형 명칭 사용
### Bad
```java
class T {
    Set<String> pns = new Set();
    Integer s = 0;
    ...

    Boolean f(String n) {
        return pns.contains(n);
    }

    Integer getS() {
        return s;
    }
}

//주석문으로 서술적인 이름을 대체할 수 없다.
class T {
    Set<String> pns = new Set(); //팀에 속한 선수 이름
    Integer s = 0; // 팀의 점수
    ...

    /**
     * @param n 플레이어의 이름
     * @return true 플레이어가 팀에 속해 있는 경우
     */
    Boolean f(String n) {
        return pns.contains(n);
    }

    /**
     * @return 팀의 점수
     */
    Integer getS() {
        return s;
    }
}
```
### Good
```java
//해결책: 서술적인 이름 짓기
class Team {
    Set<String> playerNames = new Set();
    Integer score = 0;
    ...

    Boolean containsPlayer(String playerName) {
        return playerNames.contains(playerName);
    }

    Integer getScore() {
        return score;
    }
}
```

## 5.2 주석문의 적절한 사용 
- 코드가 `무엇`을 하는지 설명
- 코드가 `왜` 그 일을 하는지 설명
- 사용 지침 등 기타 정보 제공

### Bad
```java
String generateId(String firstName, String lastName){
    //"{이름}.{성} 의 형태로 ID를 생성한다.
    return firstName + "." + lastName;
}

String generateId(String[] data){
    //data[0]는 유저의 이름이고 data[1]은 성이다.
    //"{이름}.{성} 의 형태로 ID를 생성한다.
    return data[0] + data[1];
}
```

### Good
```java
String generateId(String[] data){
    return firstName(data) + "." + lastNmae(data);
}

String firstName(String[] data) {
    return data[0];
}

String lastName(String[] data){
    return data[1];
}
```


### Good
- 주석문은 상위 수준의 요약 정보를 제공할 수 있다.
- 주석문은 코드의 이류를 설명하는 데 유용하다.
```java

/**
 * 스트리밍 서비스 유저에 대한 자세한 사항을 갖는다.
 * <p> 
 * 이 클래스는 데이터베이스에 직접 연결하지 않는다. 대신 메모리에 저장된 값으로
 * 생성된다. 따라서 이 클래스가 생성된 이후에 데이터베이스에서 이뤄진 변경 사항을 
 * 반영하지 않을 수 있다.
 */
class User{
    private final Integer username;
    private final String firstName;
    private final String lastName;
    private final Version signupVersion;
    ...
    
    String getUserId(){
        if(signupVersion.isOlderThan("2.0")){
            // (v2.0 이전에 등록한) 레거시 유저는 이름으로 ID가 부여된다.
            // 자세한 내용은 #4218 이슈를 보라.
            return firstName.toLowerCase() + "." + lastName.toLowerCase();
        }
        return username;
    }
}
```

## 5.3 코드 줄 수를 고정하지 말라
함수의 길이가 너무 길다면 두가지 일을 하는것은 아닌지 체크해 볼 필요가 있다.  
하지만 너무 짧다고 무조건 좋은것은 아니다.

### Bad
```java
//아래의 UInt16은 unsigned int 16비트 이다.(자바에는 없어서 남겨둔다.) -> Integer.unsignedInt(int)
Boolean isIdValid(UInt16 id) {
    return countSetBits(id & 0x7FFF) % 2 == ((id & 0x8000) >> 15);
}
```

### Good
아래는 코드의 양은 더 많지만 가독성은 높은 코드이다.

```java
Boolean isIdValid(UInt16 id){
    return extractEncodedParity(id) == calculateParity(getIdValue(id));
}

private const UInt16 PARITY_BIT_INDEX = 15;
private const UInt16 PARITY_BIT_MASK = (1 << PARITY_BIT_INDEX);
private const UInt16 VALUE_BIT_MASK = ~PARITY_BIT_MASK;

private UInt16 getIdValue(UInt16 id){
    return id & VALUE_BIT_MASK;
}

private UInt16 extractEncodedParity(UInt16 id){
    return (id & PARITY_BIT_MASK) >> PARITY_BIT_INDEX;
}

// 패리티 비트는 1인 비트의 수가 짝수면 0이고
// 홀수면 1이다.
private UInt16 calculateParity(UInt16 value){
    return countSetBits(value) % 2;
}
```

## 5.4 일관된 코딩 스타일을 고수하라
### Bad
```java
class GroupChat {
    ...
    
    end(){
        connectionsManager.terminateAll();
    }
}
```

위 코드는 클래스 내의 인스턴스 변수로 보이고, 해당 커넥션만 종료한다.   
서버가 관리하는 다른 채팅은 영향을 받지 않을것으로 보인다.  

왜냐하면 캐멀 케이스로 작성되었기 때문에 보지 않고도 멤버 변수라고 가정할 수 있다.

하지만 불행히도 `connectionManager` 는 클래스 이름이고 `terminateAll()`는 정적 함수다.

### Good
스타일 가이드를 채택하고 따르라
[Google Java Convention](https://google.github.io/styleguide/javaguide.html) 와 같은 컨벤션을 선택하여 따라야 한다.
일관된 코딩 스타일은 버그를 예방하는데 도움이 된다.
```java
class GroupChat {
    ...
    
    end(){
        ConnectionsManager.termiateAll();
    }
}
```

## 5.5 깊이 중첩된 코드를 피하라
들여쓰기 너무 많이 하지 말자.

더 작은 함수로 분리한다면 else를 쓰지 않아도 될 뿐더러 보다 명확하게 읽을 수 있을 것이다.
이때 더 작은 함수로 분리하는 기준은 추상화 레벨이 될 것이다. 

## 5.6 함수 호출도 가독성이 있어야 한다.
- 인수가 무엇을 위한 것인지
- 무슨 역할을 하는지
### Bad
```java
void sendMessage(String message, Integer priority, Boolean allowRetry){
    ...
}

sendMessage("메시지",1,1)
```

### Good
```java
void sendMessage(String message, MessagePriority priority, RetryPolicy retryPolicy){
    ...
}

sendMessage("메시지",new MessagePriority(1), RetryPolicy.ALLOW_RETRY);
```

생성자의 경우에는 빌더 패턴을 고려해라. -> 추후 7장에서 다룬다.
setter는 값이 빈 경우가 생길수 있다. ->  Effective Java 아이템 2 참고

## 5.7 설명되지 않은 값을 사용하지 말라
- 하드 코딩 하지 마라   
- [매직넘버](https://jake-seo-dev.tistory.com/155) 쓰지 말라

### Bad
```java
void validateSize(int number){
    if(number < 0 || number > 45){
        throw new IllegalArgumentException("number 는 0~45 사이의 값 이어야 합니다.");
    }
} 
```
### Good

```java
public static final int MIN_VALUE = 0;
public static final int MAX_VALUE = 0;

void validateSize(int number) {
    if (number < MIN_VALUE || number > MAX_VALUE) {
        throw new IllegalArgumentException(NumberError.INVALID_SIZE.getMessage());
    }
}

enum NumberError {
    INVALID_SIZE("number 는 %d~%d 사이의 값 이어야 합니다.".formatted(MIN_VALUE, MAX_VALUE));

    private final String message;

    NumberError(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }
}
```

## 5.8 익명 함수를 사용하라
[Effective Java 아이템 42](../../EFFECTIVE_JAVA_3/아이템_42.md) 참고

## 5.9 프로그래밍 언어의 새로운 기능을 적절하게 사용하라
책에서는 [sort](../../EFFECTIVE_JAVA_3/아이템_42.md)를 예시로 들고 있다. 