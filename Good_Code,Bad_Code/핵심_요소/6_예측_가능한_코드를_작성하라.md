# 6_예측 가능한 코드를 작성하라.md

## 이번 장에서는 다음과 같은 내용을 다룬다.

- 코드가 어떻게 예측을 벗어나 작동할 수 있는지
- 소프트웨어에서 예측을 벗어나는 코드가 어떻게 버그로 이어질 수 있는지
- 코드가 예측을 벗어나지 않도록 보장하는 방법

## 6.1 매직값을 반환하지 말아야 한다.

매직값은 이전장인 5.7에서도 다루었다.

때때로 매직값은 우연히 발생할 수 있다.

### Bad Code

```java
import java.util.stream.Collectors;

Integer minValue(List<Integer> values) {
    int minValue = Integer.MAX_VALUE;
    for (int value : values) {
        minValue = Math.min(value, minValue);
    }
    return minValue;
}
```

위의 예시는 매직값이 우연히 발생할 수 있다는 것을 보여주기 위한 예시이다.

잘 정의된 Collections을 사용면 아래와 같이 깔끔한 함수가 나온다.

### Good Code

```java
import java.util.Collections;

Integer minValue(List<Integer> values) {
    return Collections.min(values);
}
```

그렇다면 API는 어떻게 예외처리를 했을까?

Throw:
ClassCastException – 컬렉션에 서로 비교 가능하지 않은 요소(예: 문자열과 정수)가 포함된 경우.
NoSuchElementException – 컬렉션이 비어 있는 경우.

**원하지 않는 동작**이 발생할 것 같을 때에 **예외를 발생** 시키고 있다.

## 6.2 널 객체 패턴을 적절히 사용하라

값을 얻을 수 없을 떄 널값이나 빈 옵셔널을 반환하는 대신 널 객체 패턴을 사용 할 수 있다. (ex. Collections.emptyList())

**널 객체 패턴**을 사용하는 이유는 이후 실행되는 로직에서 **널값으로 인해 시스템 피해가 가지 않도록** 하기 위함이다.
하지만 null을 사용하지 않는다면 그 의도를 명확히 해야한다. (내가 원하지 않는 방식으로 작동하는 것을 막기 위해 예외를 던지는것과 같은)

## 6.3 예상치 못한 부수 효과를 피하라

- 호출한 쪽의 가정을 깨트리기 (함수명을 보고 판단하는데 비용이 큰 부수효과 ex. canvas.redraw())
- 다중 쓰레드 코드의 버그

**`상태 변경`하거나 `가변성`이 있다면 꼭 함수 명에 기입!!!**

### Bad

```java
class UserDisplay {
    private final Canvas canvas;
    ...

    Color getPixel(int x, int y) {
        canvas.redraw();    //다시 그리기 이벤트를 발생하는 것은 부수 효과이다.
        PixelData data = canvas.getPixel(x, y);
        return new Color(
                data.getRed(),
                data.getGreen(),
                data.getBlue()
        );
    }
}
```

### Good

```java
class UserDisplay {
    private final Canvas canvas;
    ...

    Color redrawAndGetPixel(int x, int y) {
        ...
    }
}
```

## 6.4 입력 매개변수를 수정하는 것에 주의하라

입력 매개변수를 변경하면 버그를 유발할 수 있다.

어떤 객체를 다른 함수에 입력으로 넘기는 것은 책을 빌려주는 것과 유사하다.
필요한 정보가 다 있지만, 책을 찢고 여백 위에 낙서하는 등의 일은 위험한 일이다.

내가 지금당장 떠오르는 해결방법은 복사해서 넘겨주거나(Collection도 안전하다) final 키워드를 이용하여 변경을 방지하거나(Collection은 변경 가능하다...)


> 방어적이어야 한다.
> 7장에서 객체를 불변으로 만드는것에 대해 살펴본다.

## 6.5 오해를 일으키는 함수는 작성하지 말라

null일 경우 아무것도 하지 않는 함수를 생각해 보자. (호출하는 쪽의 부담을 덜어주려고 했지만 예상을 벗어나는 코드를 초래하게 되었다.)
사용자는 정상적으로 출력했다고 생각하지만 실제로는 아무것도 하지 않았다.

이를 방지하기 위해서 중요한 입력은 필수 항목으로 만들어야 한다.

## 6.6 미래를 대비한 열거형 처리

if 문을 이용하여 열거형을 처리할 경우 추가된 Enum에 대하여 컴파일 오류 없이 작동하지만 실제로는 엄청난 버그를 유발할 수 있다.
이를 방지하기 위해 switch 문을 사용하거나(사용자 측) Enum별로 다른 값을 반환하도록 만들어야 한다.(Enum측)

## 요약

다른 개발자가 작성하는 코드는 종종 우리가 작성하는 코드에 의존한다.

- 다른 개발자가 우리 코드의 기능을 잘못 해석하거나 처리해야 하는 특수한 경우를 발견하지 못하면,
우리가 작성한 코드에 기반한 그 코드에서 버그가 발생할 가능성이 크다.
- 코드를 호출하는 쪽에서 예상한대로 동작하기 위한 좋은 방법 중 하나는 중요한 세부 사항이 코드 계약의 명백한 부분에 포함되도록 하는 것이다.
- 우리가 사용하는 코드에 대해 허술하게 가정을 하면 예상을 벗어나는 또 다른 결과를 볼 수 있다.
    - 열거형에 추가되는 새 값을 예상하지 못한 경우
    - 의존해서 사용중인 코드가 가정을 벗어날 경우, 코드 컴파일을 중지하거나 테스트가 실패하도록 하자.
- 테스트만으로는 예측을 벗어나는 코드의 문제를 해결 할 수 없다.(동시성 문제, Lock, 멀티쓰레드)

## 나의 결론
상태가 변할 경우 무조건적으로 명시한다.(함수명에 무조건)
내가 원하지 않는 상태에서는 예외를 발생시킨다.
또한 값을 변경하지 못하도록 복사해서 전달하거나(getter의 경우) 불변 객체를 사용한다.(일급컬렉션, setter 사용x)
멀티 쓰레드 환경에서는 인스턴스 변수를 저장하지 않는 클래스를 사용한다. (Service, Controller)