## 아이템 46.md

> 스트림에서는 부작용 없는 함수를 사용하라

- 스트림은 함수형 프로그래밍에 기초한 패러다임이다.

- 함수형 프로그래밍은 수학적 함수의 계산으로 취급하고 `상태와 가변 데이터를 멀리`하는 프로그래밍 패러다임의 하나이다.

- 스트림 연산에 `건내는 함수 객체는 모두 부작용이 없어야 한다.`

- 스트림은 이전 단계의 결과를 받아서 처리하는 `순수 함수`여야 한다.

순수 함수란 오직 입력만이 결과에 영향을 주는 함수이다`y=f(x)`.
즉 외부의 상태를 변경하면 안되는 것이다.


다음은 로또 당첨 등수에 맞는 개수를 세어 리턴하는 함수이다.

```java
public Map<WinningLottoStatus, Integer> getWinningLottoStatusAndCounts(
        WinningLotto winningLotto,
        List<Lotto> purchasedLottoList
) {
    Map<WinningLottoStatus, Integer> result = new HashMap<>();
    putWinningLottoStatus(result); // 전 등수 0으로 초기화

    for (Lotto lotto : purchasedLottoList) {
        WinningLottoStatus status = WinningLottoStatus.getWinningLottoStatus(winningLotto, lotto);
        if (status == null) {
            continue;
        }
        result.put(status, result.get(status) + 1);
    }
    return result;
}

private void putWinningLottoStatus(Map<WinningLottoStatus, Integer> map) {
    Arrays.stream(WinningLottoStatus.values())
            .forEach(s -> map.put(s, 0));
}
```
```java
public Map<LottoRank, Integer> getRankResults(
        WinningLotto winningLotto,
        List<Lotto> purchasedLotto
) {
    Map<LottoRank, Integer> result = new HashMap<>();

    purchasedLotto.stream()
            .map(lotto -> rankOf(winningLotto, lotto))
            .filter(rank -> rank != LottoRank.NONE)
            .forEach(rank -> result.merge(rank, 1, Integer::sum));

    return result;
}

private LottoRank rankOf(WinningLotto winningLotto, Lotto lotto) {
    return LottoRank.valueOf(
            winningLotto.matchCount(lotto),
            winningLotto.matchBonus(lotto));
}
```
위 코드는 내가 리팩토링을 진행하면서 짰던 코드이다.

분명 이전 코드보다 가독성이 좋아진것도 맞고 결과가 올바른것도 맞다.

하지만 절대로 Stream 코드라고 할 수 없다.

종언 부분인 forEach 에서 상태를 변경하고 있기 때문이다.
오로지 이전 스트림에만 영향을 받아야 하지만 외부 변수의 값을 변경하고 있기 때문에 순수함수가 아닌것이다.

아래는 올바르게 작성한 모습이다.
```java
 public Map<LottoRank, Long> getRankResults(
            WinningLotto winningLotto,
            List<Lotto> purchasedLotto
    ) {
        return purchasedLotto.stream()
                .collect(groupingBy(lotto ->
                        rankOf(winningLotto, lotto), counting()));
    }

    private LottoRank rankOf(WinningLotto winningLotto, Lotto lotto) {
        return LottoRank.valueOf(
                winningLotto.matchCount(lotto),
                winningLotto.matchBonus(lotto));
    }
```

책에서는 
forEach 연산은 기능이 가장 적고 가장 `덜` 스트림스럽기 때문에
**`계산 결과를 보고할 때만 사용하고, 계산하는 데는 쓰지 않는것이 좋다.`**
라고 말한다.

이후 추가로 Collectors의 메서드에 대해 설명한다.







