# 📅 [2025-09-08] Daily Log - GoodCode & BadCode

## 1️⃣ 오늘 읽은 내용
- 책 제목: GoodCode & BadCode
- 챕터 / 페이지: Chapter 1,2
- 핵심 내용 요약:
  - 추상화 계층으로 세분화하면 가독성, 모듈화, 재사용, 일반화 및 테스트 용이성이 향상된다.

## 2️⃣ 인상 깊었던 원칙 / 팁
나는 항상 추상화의 레벨에 대해 고민해왔다. 응집력은 높이는데 결합도를 낮추고 싶다.  
어디까지 분리해야하는지 그 근거가 부족했다. 기준이 모호하다.  

이 책에서는 핵심 요소에 반하는지 체크하라고 한다.
- 코드를 읽을 수 없다. (가독성)
- 코드가 특별히 모듈화되어 있지 않다. (모듈성)
- 코드를 재사용할 수 없다. (재사용성)
- 코드를 일반화할 수 없다.
- 코드를 제대로 테스트하기 어렵다. (테스트 용이성)

추가적으로 인터페이스를 이용한다면 추상화 계층을 깔끔하게 구현할 수 있다. -> 층이 너무 얇아지지 않도록 주의해야 한다.

## 3️⃣ 예제
### Bad Code:
```java
class TextSummarizer {
    ...
    String summarizeText(String text){
        return splitIntoParagraphs(text)
                .filter(paragraph -> calculateImportance(paragraph) >=
                    IMPORTANCE_THRESHOLD)
                .join("\n\n");
    } 
    
    private Double calculateImportance(String paragraph){
        ...
    }
    
    private List<String> splitIntoParagraphs(String text){
        ...
    }
}
```
#### 문제점
문맥을 요약하는것 이외에도 여러 역할을 하고 있다.
1. 텍스트를 단락으로 분할
2. 텍스트 문자열의 중요도 점수 계산

- 질문 1. 텍스트를 요약하는것에만 관련이 있지 않나? -> 높은 층위에서 보자면 맞는 말이지만 위에서 말한 핵심 요소를 충족하지 못한다. 

### Good Code:
```java
class TextSummarizer{
    private final ParagraphFinder paragraphFinder;
    private final TextImportanceScorer importanceScorer;
    
    TextSummarizer(
            ParagraphFinder paragraphFinder, 
            TextImportanceScorer importanceScorer) {
        this.paragraphFinder = paragraphFinder;
        this.importanceScorer = importanceScorer;
    }
    
    String summarizeText(String text){
        return paragraphFinder.find(text)
                .filter(paragraph -> 
                    importanceScorer.isImportant(paragraph))
                .join("\n\n");
    }
}

class ParagraphFinder{ ... }
interface TextImportanceScorer{...}
class WordBasedScorer implements TextImportanceScorer{...}
class ModelBasedScorer implements  TextImportanceScorer{...}
```
위의 코드는 다음과 같은 장점이 있다.
- 코드가 좀 더 모듈화되고 재구성할 수 있게 됐다.
- 코드의 재사용성이 좀 더 높아졌다.(하위 메서드)
- 코드의 테스트 용이성이 좀 더 높아졌다.


## 4️⃣ 내 코드 적용 아이디어
- 책 내용을 내 프로젝트 / 연습 코드에 적용할 수 있는 방법
    1. class Lotto는 랜덤한 6가지 숫자를 주입받아 사용하는 클래스이다.
       랜덤한 값은 테스트가 어려웠고 나는 그 값을 주입을 받는것으로 리팩토링을 진행하였다.
```java
public class LottoService {
    private final LottoNumberGenerator lottoNumberGenerator;

    public LottoService(LottoNumberGenerator lottoNumberGenerator) {
        this.lottoNumberGenerator = lottoNumberGenerator;
    }

    public List<Lotto> purchaseTicket(LottoMoney lottoMoney) {
        Supplier<Lotto> createLotto = () ->
                new Lotto(lottoNumberGenerator.getOrderedLottoNumbers());

        return Stream.generate(createLotto)
                .limit(lottoMoney.getPurchaseCount())
                .toList();
    }
    //...
}

public interface LottoNumberGenerator {
  List<Integer> getOrderedLottoNumbers();
}

public class LottoNumbersGeneratorImpl implements LottoNumberGenerator {
  @Override
  public List<Integer> getOrderedLottoNumbers() {
    return Randoms.pickUniqueNumbersInRange(Lotto.MIN_VALUE, Lotto.MAX_VALUE, Lotto.SIZE)
            .stream()
            .sorted()
            .toList();
  }
}
```