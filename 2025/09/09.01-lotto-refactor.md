# Enum 기반으로 당첨 규칙 응집 & 스트림 리팩토링
**날짜:** 2025-09-01  
**커밋:** [c641e89](https://github.com/bee9827/java-lotto-6_online/commit/c641e89a58b6925f12c45cf86fe17906512ac737)

---

## 🔍 변경점 요약
### LottoRank
- `WinningLottoStatus` → `LottoRank`로 전환
- 정적 메서드 명 변경: `getWinningLottoStatus` → `valueOf`
- 모델 의존 제거: `(WinningLotto, Lotto)` → `(int matchCount, boolean matchBonus)`
- `Stream` + `Predicate`로 판정 로직 간결화

### LottoService
- 메서드 추출로 읽기 흐름 정리 (`rankOf`)
- `Stream.generate`, `merge` 등 함수형 스타일 적용

---

## 💡 배운 점
- 함수를 볼때 흐름이 보이도록 `추상화`를 해야 잘 읽힌다. 
- indent를 의도적으로 사용해야 한다. -> Stream 사용 권장
- 추상화를 할 때 `함수를 분리` or `함수형 인터페이스`를 사용하면 좋다.
- 명확한 메서드 명이 필요하다. 의도가 보이도록 네이밍을 해야한다 (static 생성자의 경우에는 convention)


## 📝 Before → After 코드 스냅샷

### 1) LottoRank 판정 (Enum 내부 로직)
**Before**
```java
public static WinningLottoStatus getWinningLottoStatus(WinningLotto winningLotto, Lotto purchasedLotto) {
    int containsCounts = winningLotto.containsCounts(purchasedLotto);
    boolean isMatchBonusNumber = winningLotto.matchBonusNumber(purchasedLotto);

    for (WinningLottoStatus status : WinningLottoStatus.values()) {
        if (status.checkCondition(containsCounts, isMatchBonusNumber)) {
            return status;
        }
    }
    return null; // 예외/NONE 처리 부재
}

private boolean checkCondition(int containsCounts, boolean isMatchBonusNumber) {
    if (this == SECOND || this == THIRD) {
        return this.containsCounts == containsCounts && isMatchBonusNumber == matchBonusNumber;
    }
    return this.containsCounts == containsCounts;
}
```
**After**
```java
public static LottoRank valueOf(int matchCount, boolean matchBonus) {
    Predicate<LottoRank> condition =
        rank -> rank.matchCount == matchCount && rank.matchBonus.contains(matchBonus);

    return Arrays.stream(LottoRank.values())
            .filter(condition)
            .findFirst()
            .orElse(NONE); // 안전한 기본값으로 수렴
}
```
변경 핵심: 모델 의존 제거, Predicate로 조건 캡슐화, NONE 기본값 처리로 NPE 여지 차단

### 2) LottoService 로또 구매 (생성 로직)

**Before**
```java
public List<Lotto> purchaseLottoList(LottoMoney lottoMoney) {
    int purchaseCount = lottoMoney.getPurchaseCount();

    List<Lotto> purchasedLottoList = new ArrayList<>();
    for (int i = 0; i < purchaseCount; i++) {
        Lotto lotto = new Lotto(lottoNumberGenerator.getOrderedLottoNumbers());
        purchasedLottoList.add(lotto);
    }
    return purchasedLottoList;
}

```

**After**
```java
public List<Lotto> purchaseTicket(LottoMoney lottoMoney) {
    Supplier<Lotto> createLotto =
            () -> new Lotto(lottoNumberGenerator.getOrderedLottoNumbers());

    return Stream.generate(createLotto)
            .limit(lottoMoney.getPurchaseCount())
            .toList();
}

```

변경 핵심: Stream.generate + limit로 “N개 생성” 의도를 선언적으로 표현

### 3) 당첨 결과 집계

**Before**
```java
public Map<WinningLottoStatus, Integer> getWinningLottoStatusAndCounts(
        WinningLotto winningLotto,
        List<Lotto> purchasedLottoList
) {
    Map<WinningLottoStatus, Integer> result = new HashMap<>();
    putWinningLottoStatus(result); // 전 등수 0으로 초기화

    for (Lotto lotto : purchasedLottoList) {
        WinningLottoStatus status = WinningLottoStatus.getWinningLottoStatus(winningLotto, lotto);
        if (status == null) {
            continue;
        }
        result.put(status, result.get(status) + 1);
    }
    return result;
}

private void putWinningLottoStatus(Map<WinningLottoStatus, Integer> map) {
    Arrays.stream(WinningLottoStatus.values())
            .forEach(s -> map.put(s, 0));
}
```

**After**
```java
public Map<LottoRank, Integer> getRankResults(
        WinningLotto winningLotto,
        List<Lotto> purchasedLotto
) {
    Map<LottoRank, Integer> result = new HashMap<>();

    purchasedLotto.stream()
            .map(lotto -> rankOf(winningLotto, lotto))
            .filter(rank -> rank != LottoRank.NONE)
            .forEach(rank -> result.merge(rank, 1, Integer::sum));

    return result;
}

private LottoRank rankOf(WinningLotto winningLotto, Lotto lotto) {
    return LottoRank.valueOf(
            winningLotto.matchCount(lotto),
            winningLotto.matchBonus(lotto));
}

```

변경 핵심: merge로 보일러플레이트 제거, NONE 필터링으로 흐름 단순화, 메서드 추출로 의도 드러냄

## ✅ 포인트 정리

함수형 인터페이스 적용: Predicate<LottoRank>로 조건을 값 객체처럼 다룸

Stream API: 생성(generate+limit), 필터링(filter), 집계(merge)에 적재적소 적용

의존 축소: Rank 판정이 모델에 의존하지 않고 순수 데이터(matchCount, matchBonus)만 받도록 변경

안전 기본값: null 대신 LottoRank.NONE으로 수렴해 호출부 복잡도 감소