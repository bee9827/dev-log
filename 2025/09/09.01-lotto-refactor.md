# Enum ê¸°ë°˜ìœ¼ë¡œ ë‹¹ì²¨ ê·œì¹™ ì‘ì§‘ & ìŠ¤íŠ¸ë¦¼ ë¦¬íŒ©í† ë§
**ë‚ ì§œ:** 2025-09-01  
**ì»¤ë°‹:** [c641e89](https://github.com/bee9827/java-lotto-6_online/commit/c641e89a58b6925f12c45cf86fe17906512ac737)

---

## ğŸ” ë³€ê²½ì  ìš”ì•½
### LottoRank
- `WinningLottoStatus` â†’ `LottoRank`ë¡œ ì „í™˜
- ì •ì  ë©”ì„œë“œ ëª… ë³€ê²½: `getWinningLottoStatus` â†’ `valueOf`
- ëª¨ë¸ ì˜ì¡´ ì œê±°: `(WinningLotto, Lotto)` â†’ `(int matchCount, boolean matchBonus)`
- `Stream` + `Predicate`ë¡œ íŒì • ë¡œì§ ê°„ê²°í™”

### LottoService
- ë©”ì„œë“œ ì¶”ì¶œë¡œ ì½ê¸° íë¦„ ì •ë¦¬ (`rankOf`)
- `Stream.generate`, `merge` ë“± í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼ ì ìš©

---

## ğŸ’¡ ë°°ìš´ ì 
- í•¨ìˆ˜ë¥¼ ë³¼ë•Œ íë¦„ì´ ë³´ì´ë„ë¡ `ì¶”ìƒí™”`ë¥¼ í•´ì•¼ ì˜ ì½íŒë‹¤. 
- indentë¥¼ ì˜ë„ì ìœ¼ë¡œ ì‚¬ìš©í•´ì•¼ í•œë‹¤. -> Stream ì‚¬ìš© ê¶Œì¥
- ì¶”ìƒí™”ë¥¼ í•  ë•Œ `í•¨ìˆ˜ë¥¼ ë¶„ë¦¬` or `í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤`ë¥¼ ì‚¬ìš©í•˜ë©´ ì¢‹ë‹¤.
- ëª…í™•í•œ ë©”ì„œë“œ ëª…ì´ í•„ìš”í•˜ë‹¤. ì˜ë„ê°€ ë³´ì´ë„ë¡ ë„¤ì´ë°ì„ í•´ì•¼í•œë‹¤ (static ìƒì„±ìì˜ ê²½ìš°ì—ëŠ” convention)


## ğŸ“ Before â†’ After ì½”ë“œ ìŠ¤ëƒ…ìƒ·

### 1) LottoRank íŒì • (Enum ë‚´ë¶€ ë¡œì§)
**Before**
```java
public static WinningLottoStatus getWinningLottoStatus(WinningLotto winningLotto, Lotto purchasedLotto) {
    int containsCounts = winningLotto.containsCounts(purchasedLotto);
    boolean isMatchBonusNumber = winningLotto.matchBonusNumber(purchasedLotto);

    for (WinningLottoStatus status : WinningLottoStatus.values()) {
        if (status.checkCondition(containsCounts, isMatchBonusNumber)) {
            return status;
        }
    }
    return null; // ì˜ˆì™¸/NONE ì²˜ë¦¬ ë¶€ì¬
}

private boolean checkCondition(int containsCounts, boolean isMatchBonusNumber) {
    if (this == SECOND || this == THIRD) {
        return this.containsCounts == containsCounts && isMatchBonusNumber == matchBonusNumber;
    }
    return this.containsCounts == containsCounts;
}
```
**After**
```java
public static LottoRank valueOf(int matchCount, boolean matchBonus) {
    Predicate<LottoRank> condition =
        rank -> rank.matchCount == matchCount && rank.matchBonus.contains(matchBonus);

    return Arrays.stream(LottoRank.values())
            .filter(condition)
            .findFirst()
            .orElse(NONE); // ì•ˆì „í•œ ê¸°ë³¸ê°’ìœ¼ë¡œ ìˆ˜ë ´
}
```
ë³€ê²½ í•µì‹¬: ëª¨ë¸ ì˜ì¡´ ì œê±°, Predicateë¡œ ì¡°ê±´ ìº¡ìŠí™”, NONE ê¸°ë³¸ê°’ ì²˜ë¦¬ë¡œ NPE ì—¬ì§€ ì°¨ë‹¨

### 2) LottoService ë¡œë˜ êµ¬ë§¤ (ìƒì„± ë¡œì§)

**Before**
```java
public List<Lotto> purchaseLottoList(LottoMoney lottoMoney) {
    int purchaseCount = lottoMoney.getPurchaseCount();

    List<Lotto> purchasedLottoList = new ArrayList<>();
    for (int i = 0; i < purchaseCount; i++) {
        Lotto lotto = new Lotto(lottoNumberGenerator.getOrderedLottoNumbers());
        purchasedLottoList.add(lotto);
    }
    return purchasedLottoList;
}

```

**After**
```java
public List<Lotto> purchaseTicket(LottoMoney lottoMoney) {
    Supplier<Lotto> createLotto =
            () -> new Lotto(lottoNumberGenerator.getOrderedLottoNumbers());

    return Stream.generate(createLotto)
            .limit(lottoMoney.getPurchaseCount())
            .toList();
}

```

ë³€ê²½ í•µì‹¬: Stream.generate + limitë¡œ â€œNê°œ ìƒì„±â€ ì˜ë„ë¥¼ ì„ ì–¸ì ìœ¼ë¡œ í‘œí˜„

### 3) ë‹¹ì²¨ ê²°ê³¼ ì§‘ê³„

**Before**
```java
public Map<WinningLottoStatus, Integer> getWinningLottoStatusAndCounts(
        WinningLotto winningLotto,
        List<Lotto> purchasedLottoList
) {
    Map<WinningLottoStatus, Integer> result = new HashMap<>();
    putWinningLottoStatus(result); // ì „ ë“±ìˆ˜ 0ìœ¼ë¡œ ì´ˆê¸°í™”

    for (Lotto lotto : purchasedLottoList) {
        WinningLottoStatus status = WinningLottoStatus.getWinningLottoStatus(winningLotto, lotto);
        if (status == null) {
            continue;
        }
        result.put(status, result.get(status) + 1);
    }
    return result;
}

private void putWinningLottoStatus(Map<WinningLottoStatus, Integer> map) {
    Arrays.stream(WinningLottoStatus.values())
            .forEach(s -> map.put(s, 0));
}
```

**After**
```java
public Map<LottoRank, Integer> getRankResults(
        WinningLotto winningLotto,
        List<Lotto> purchasedLotto
) {
    Map<LottoRank, Integer> result = new HashMap<>();

    purchasedLotto.stream()
            .map(lotto -> rankOf(winningLotto, lotto))
            .filter(rank -> rank != LottoRank.NONE)
            .forEach(rank -> result.merge(rank, 1, Integer::sum));

    return result;
}

private LottoRank rankOf(WinningLotto winningLotto, Lotto lotto) {
    return LottoRank.valueOf(
            winningLotto.matchCount(lotto),
            winningLotto.matchBonus(lotto));
}

```

ë³€ê²½ í•µì‹¬: mergeë¡œ ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì œê±°, NONE í•„í„°ë§ìœ¼ë¡œ íë¦„ ë‹¨ìˆœí™”, ë©”ì„œë“œ ì¶”ì¶œë¡œ ì˜ë„ ë“œëŸ¬ëƒ„

## âœ… í¬ì¸íŠ¸ ì •ë¦¬

í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ ì ìš©: Predicate<LottoRank>ë¡œ ì¡°ê±´ì„ ê°’ ê°ì²´ì²˜ëŸ¼ ë‹¤ë£¸

Stream API: ìƒì„±(generate+limit), í•„í„°ë§(filter), ì§‘ê³„(merge)ì— ì ì¬ì ì†Œ ì ìš©

ì˜ì¡´ ì¶•ì†Œ: Rank íŒì •ì´ ëª¨ë¸ì— ì˜ì¡´í•˜ì§€ ì•Šê³  ìˆœìˆ˜ ë°ì´í„°(matchCount, matchBonus)ë§Œ ë°›ë„ë¡ ë³€ê²½

ì•ˆì „ ê¸°ë³¸ê°’: null ëŒ€ì‹  LottoRank.NONEìœ¼ë¡œ ìˆ˜ë ´í•´ í˜¸ì¶œë¶€ ë³µì¡ë„ ê°ì†Œ